<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8" />
  <title>Shape Index Specification</title>

  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  <script src="./common/local-biblio.js" class="remove"></script>
  <script src="./common/fixup.js" class="remove"></script>

  <script class="remove">
    // All config options at https://respec.org/docs/
    var respecConfig = {
      localBiblio: localBibliography,
      specStatus: "unofficial",
      shortName: "shape-index",
      copyrightStart: "2024",

      github: "https://github.com/constraintAutomaton/shape-index-specification",

      //        implementationReportURI: "https://w3c.github.io/sparql12-protocol/reports/",
      //        errata:               "https://w3c.github.io/sparql12-protocol/errata/",

      editors: [
        { name: "Bryan-Elliott Tam", w3cid: "159160" },
        { name: "Ruben Taelman", w3cid: "84199" },
      ],


      //doJsonLd:     true,

      lint: { "no-unused-dfns": false }
    };
  </script>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <section id="abstract">
    <h2>Abstract</h2>
    <p>The open web and linked data are often seen as complementary,
      yet this doesn't imply that data publication should be disorganized.
      While the web as a whole lacks a clear structure,
      web segments can still be structured through hypermedia descriptions and precise specifications.
      This document introduces the <em>Shape Index</em> specification,
      designed to facilitate data quality control and execution of queries in decentralized unindexed networks of linked
      data.
      The shape index leverages RDF data shapes to provide explicit constraints on data publication and provide
      lightweight yet
      powerful structural and statistical information about the content of RDF datasets in decentralized networks.
    </p>
  </section>

  <section id="aim">
    <h2>Aim, scope, and intended audience</h2>
    <p>
      The present document outlines how to annotate networks of datasets with a shape index and proposes methods
      by which query engines can optimize traversal queries using the information from the index.
      This document does not propose a mechanism for data validation, particularly on updates affecting
      the data model or the structure of the publication.
      The document is aimed particularly at developers who want to use the shape index for query optimization.
    </p>
  </section>

  <section id="conformance">

    <p>
      The following prefixes are used throughout the document.
    </p>
    <pre class="query nohighlight">
      PREFIX si: &lt;http://www.shapeindex.com#&gt; .
      PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
      PREFIX ex: &lt;http://www.example.com#&gt; .
    </pre>
  </section>

  <section id="terminology">
    <h2>Terminology</h2>
    <dl>
      <dt>Subweb</dt>
      <dd>A subset of the web, defined by a set of IRIs or IRI patterns (IRI patterns are considered as sets of IRI).
      </dd>

      <dt>RDF Data Shape</dt>
      <dd>A schema definition of an RDF subgraph, independent of any specific shape language. Typically, this MAY be
        formalized in ShEx [[SHEX-SPEC]] or SHACL [[SHACL]].
        The term is used interchangeably with the shortening shape.
      </dd>

      <dt>Complete Index</dt>
      <dd>An index that fully describes every resource within its associated subweb.</dd>

      <dt>Open shape</dt>
      <dd>A shape with an open world assumption, meaning that an RDF graph respecting the shape can be a subset of the
        shape definition given no contradiction with the shape definition with for instance negative properties or
        non-respecting term cardinalities.</dd>

      <dt>Closed shape</dt>
      <dd>A shape with a close world assumption,
        meaning that the shape describes fully the contain of an RDF graph.</dd>
    </dl>
  </section>

  <section id="context">

    <h2>Why a Shape Index</h2>
    <bold>
      This section is non-normative
    </bold>

    <p>
      When publishing linked data providers have a lot of concerns ranging from the data model, ontology design to the
      exposition through an endpoint and
      distribution of
      the dataset.
      When the data publisher distribute its data they often structured it a logical way, for instance data about books
      is located at `ex:books`,
      personal data at `ex:profile` and so on.
    </p>

    <p>
      The Solid specification [[SOLID-SPEC]] with its concept of storages often referred as pod [[TAELMAN-2023]] with
      their use of the LDP specification [[LDP-SPEC]],
      provide a form of structured to distributed linked data by delimiting the domain of publication of a dataset
      following a tree structure URL patting.
      Such a structure provides a mean for query engines to have some domain information about the publication of data
      from a specific data publisher, but
      it gives little actual information about the content of a pod, or more generally of a dataset to infer if it
      content query relevant information or for query planning purposes.
      The type index specification [[TYPE-INDEX-SPEC]], provide a limited means to know the content of a dataset or more
      specifically a Solid pod that
      can be exploited by query engines [[TAELMAN-2023]].
      Succinctly the type index consists of a mapping between types and subweb with a single Solid pod.
      The type index has two problems, first it only necessitates for the data provider to specify a type with no extra
      information about
      how properties associated with this type limit the capacity of query engines to determine if the sources are
      relevant and provide very limited structural
      and statistical information about the content of a data source.
      Furthermore, the type index is strongly tied to Solid by not defining concretely the subweb it operates or whether
      or not it describes the whole dataset within this subweb,
      making this solution not generalizable for context outside of Solid.
    </p>

    <p>
      The Shape Trees specification [[SHAPE-TREES-SPEC]] is another effort in that direction.
      This specification proposes an indexing system centered around RDF data shapes alleviating the problem of limited
      structural and statistical information about the content of data from the type index.
      However, it suffers from its complexity and not a concrete definition of subweb (<a href="https://shapetrees.org/"
        target="_blank">the specification is somewhat tied to Solid</a>).
    </p>

    <p>
      We propose a Shape Index as a generalizable and extendable solution for decentralized RDF data publication data
      summarization.
      It can be considered as an evolution of the type index using the concept of shapes from the shape trees but in a
      simpler manner.
      The focus of the shape index however is query optimization while providing low cost for data providers statistical
      and structural
      information to the user.
      The specification may evolve by providing optional richer higher-cost extra statistical information about data
      sources for better
      query optimization.
      Like the shape trees the shape index is a mapping of RDF data shapes with resources, however, it proposes an
      explicit definition of the subwebs
      the shape index operates in, it also proposes information about whether or not the index describes each resource
      of the subweb, furthermore, it gives
      the possibility of having disjointed targets
      and subwebs and negative entries to describe what is not inside a target or the whole subweb.
    </p>

    <img src="./figure/schema.drawio.svg" alt="schema of the vocabulary of the shape index" width="100%" />


  </section>

  <section id="shape-index">
    <h2>Shape Index</h2>
    <p>
      A shape index is a scoped mapping between sets of RDF resources and RDF data shapes.
      In this context, a scope means that the index is characterized by a pair identifying a subweb `si:subweb` and the
      completeness of the index `si:complete`.
      A subweb is a set of IRI or IRI patterns manage by the data provider, the completeness of a
      shape index indicates if every resource in the subweb is associated with a shape.
      To create a disjunct subweb, a data publisher MUST use multiple times the predicate `si:subweb` which MUST be
      interpreted as a union of sets of IRI (considering that an IRI pattern is a set of IRI already).
      This characterization of the scope of the index is useful for two reasons.
      First, query optimizations related to the shape index are local, hence it is interesting for query engines
      to know which subwebs are affected by the optimization when performing traversal queries.
      Second, it is OPTIONAL to describe within a shape index every resource of a subweb, however, it is RECOMMENDED.
      Data providers might not want to describe every resource in its subweb to reduce potential computational time
      associated
      with keeping the mapping valid or to give themselves more flexibility in their data publication paradigm in a
      section of their subweb.
    </p>

    <p>
      The core feature of the shape index is its mappings.
      A shape index can have multiple entries identified by the term`si:entry`.
      Each entry includes a target set identified by the term `si:range`.
      Target sets are bound by a shape identified by the term `si:shape`.
      The target is a set of RDF resources where every triple within them MUST be validated by the shape linked to the
      target through a `si:shape` annotation.
    </p>

    <pre class="resultTurtle">
      &lt;http://mySubweb.com/index1&gt; a si:ShapeIndex ;
        si:subweb &lt;http://mySubweb.com/&gt; ;
        si:subweb "http://mySubweb.com/0/data/.*/*" ;
        si:entry [
          si:shape ex:profile#ProfileShape ;
          si:range &lt;http://mySubweb.com/profile&gt;
        ], [
          si:shape ex:movieReview#movieReviewShape ;
          si:range "http://mySubweb.com/0/data/movie_review/.*"
        ] , [
          si:shape &lt;http://mySubweb.com/readingList#readingListShape&gt; ;
          si:range &lt;http://mySubweb.com/0/data/personal_reading_list&gt;
          si:range &lt;http://mySubweb.com/0/data/research/paper_list&gt;
          si:range "http://mySubweb.com/0/data/reading_list/*"
        ] ;
        si:complete true .  
    </pre>

    <p>
      Furthermore, every set of triples within the subweb respecting a shape with a close world assumption associated
      with a `si:shape` MUST be inside a resource of the target annotated with the shape.
      It is RECOMMENDED to use shapes with close-world assumptions.
      If shapes with open-world assumptions are used then, triples respecting the shape SHOULD be inside a resource of
      the target.
    </p>

    <p>
      Given shapes contained with each other used as binding for targets (see the example below and notice that the
      shapes are open) then a set of triples respecting the most restrictive shape (`ex:Citizen` in the example) SHOULD
      be located inside the resources of this target.
      In a similar case but with closed shapes, the set of triples MUST be located at the target of the most restrictive
      shape.
      If a set of triples can be validated by an open and a closed shape, the set MUST be inside the target of the
      closed shape. A resource MUST only be bound to a maximum of one shape.
    </p>

    <pre class="data">
      PREFIX ex: &lt;http://example.com/#&gt;
      PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
      PREFIX school: &lt;http://school.example/#&gt;
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

      ex:Human {
        foaf:name xsd:string ;
      }

      ex:Citizen {
        foaf:name xsd:string ;
        ex:socialSecurityNumber xsd:string ;
      }
    </pre>
  </section>

  <section id="negative-entries">
    <h2>Negative Entries</h2>
    <p>
      The shape index provides the ability to describe RDF data shapes that are not present within a subweb.
      This is indicated using the `si:excludes` property with a specific shape associated.
      These shapes MUST adhere to a close-world assumption, ensuring that no sets of triples within the entire subweb
      validate against this shape.
      It is RECOMMENDED to use these entries alongside shape constraints in the index, particularly to specify when
      nested shapes are absent from the subweb.
    </p>

    <pre class="resultTurtle">
      &lt;http://mySubweb.com/index2&gt; a si:ShapeIndex ;
        si:subweb "http://mySubweb.com/.*" ;
        si:entry [
          si:shape ex:profile#ProfileShape ;
          si:range &lt;http://mySubweb.com/profile&gt;
        ];

        si:entry [
          si:shape ex:plant#PlantShapes;
          si:excludes true ;
          si:range si:indexSubweb;
        ];

        si:entry [
          si:shape ex:plant#CarShapes;
          si:excludes true ;
          si:range &lt;http://mySubweb.com/toy&gt;
        ];
    </pre>
  </section>

  <section id="shape-index-discovery">
    <h2>How to Discover a Shape Index</h2>
    <p>
      The discovery of the shape index is left to the data provider.
      However, two approaches are RECOMMENDED.
    </p>

    <p>
      The data provider can use the predicate`si:shapeIndexLocation` with as an object the IRI of the shape index.
      This triple can be placed at convenient locations in the data provider subweb.
      Examples of such placements are at the root, at the location where other dataset information is provided, or in
      every file of the subweb.
    </p>

    <p>
      Another RECOMMENDED approach is to advertise the location of the shape index in the HTTP header.
      This SHOULD be in the form
    <pre class="data">
        Link: <iri-of-the-shape-index>; rel="http://www.shapeindex.com#shapeIndexLocation".
      </pre>

    </p>
  </section>

  <section id="query-optimization">
    <h2>Shape Index for Query Optimization</h2>

    <bold>
      This section is non-normative
    </bold>

    <p>
      One of the main objectives of the shape index is query optimization.
      This section provides an overview of the current approaches used to optimize queries with the shape index.
      As this section is non-normative and practices can evolve, it is subject to change. Readers are encouraged to
      contact the maintainers to propose new approaches or suggest extensions to the shape index based on techniques
      that build upon this approach.
    </p>

    <h3>Search Space Optimization</h3>
    <p>
      The shape index shares some similarities with the Type Indexes [[TYPE-INDEX-SPEC]].
      Data discovery techniques like the one presented by <a data-cite="TAELMAN-2023#">Taelman and Verborgh</a>
      [[TAELMAN-2023]] can be
      employed with
      small adaptations.
      <a data-cite="TAELMAN-2023#">Taelman and Verborgh</a>'s technique involves pruning sources
      associated with entries that do not share predicates with the user's query. Although this approach is an
      non-evaluated extension of their original method, it is expected to deliver performance that is equal to or better
      than the results presented in their paper.
    </p>

    <p>
      Another approach, however, built to use the shape index, has been proposed by <a data-cite="TAM-2024#">Tam et
        al.</a> [[TAM-2024]] .
      This approach involves translating
      shapes into SPARQL algebra and performing a query containment problem between the user’s query and the translated
      shapes to determine which sources to dereference, taking into account the subweb and the completeness of the
      index. This method has been shown to significantly reduce query execution time compared to the approach by
      <a data-cite="TAELMAN-2023#">Taelman and Verborgh</a>. However, it does not consider negative
      entries and has not been as extensively evaluated as <a data-cite="TAELMAN-2023#">Taelman and Verborgh</a>'s
      method.
    </p>
  </section>

  <section id="vocabulary">
    <h2>Vocabulary</h2>
    <p>
      This section present the vocabulary to define a Shape Index.
    </p>

    <h3>`si:ShapeIndex`</h3>
    <p>A Shape Index</p>
    <h4>Domain</h4>
    <h4>Range</h4>
    <p>`si:subweb`, `si:complete`, `si:entry`, `si:excludes`</p>

    <h3>`si:shapeIndexLocation`</h3>
    <p>
      Indicate that a shape index is located at the IRI at the object position of a triple using this term at the
      predicate position.
    </p>
    <h4>Domain</h4>
    <h4>Range</h4>
    <p>`si:ShapeIndex`</p>

    <h3>`si:subweb`</h3>
    <p>
      The section of the web that the shape index caracterizes.
      It can be a single IRI or IRI pattern in the form of a regex or a set of IRI and/or regex IRI pattern.
      To represent a set multiple `si:subweb` predicate MUST be defined, thus the subweb does not have to be
      in a tree structure.
    </p>
    <h4>Domain</h4>
    <p>`si:ShapeIndex`</p>
    <h4>Range</h4>
    <p>`xsd:string`</p>

    <h3>`si:complete`</h3>
    <p>
      A flag indicating if a shape index is complete, thus, every resource inside the subweb is describe by the index.
    </p>
    <h4>Domain</h4>
    <p>`si:ShapeIndex`</p>
    <h4>Range</h4>
    <p>`xsd:boolean`</p>

    <h3>`si:Entry`</h3>
    A shape index entry mapping a shape of resources to an RDF shape.
    <h4>Domain</h4>
    <h4>Range</h4>
    <p>`si:shape`, `si:range`</p>

    <h3>`si:shape`</h3>
    The shape binding a `si:range`.
    <h4>Domain</h4>
    <p>`si:Entry`</p>
    <h4>Range</h4>

    <h3>`si:range`</h3>
    The target of the index must respect the shape defined with the associated `si:shape` in the `si:Entry`.
    <h4>Domain</h4>
    <p>`si:Entry`</p>
    <h4>Range</h4>

    <h3>`si:excludes`</h3>
    Indicate that a shape validate data not contain in the subweb of a shape index.
    <h4>Domain</h4>
    <p>`si:ShapeIndex`</p>
    <h4>Range</h4>

    <h3>`si:indexSubweb`</h3>
    Indicate that the target is the whole subweb of the current shape index instance
    <h4>Domain</h4>
    <p>`si:range`</p>
    <h4>Range</h4>
  </section>

  <section id="index"></section>

</body>

</html>