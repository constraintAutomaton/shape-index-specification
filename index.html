<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8" />
  <title>Shape Index Specification</title>

  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  <script src="./common/local-biblio.js" class="remove"></script>
  <script src="./common/fixup.js" class="remove"></script>

  <script class="remove">
    // All config options at https://respec.org/docs/
    var respecConfig = {
      localBiblio: localBibliography,
      specStatus: "draft",
      shortName: "shape-index",
      copyrightStart: "2024",

      github: "https://github.com/constraintAutomaton/shape-index-specification",

      //        implementationReportURI: "https://w3c.github.io/sparql12-protocol/reports/",
      //        errata:               "https://w3c.github.io/sparql12-protocol/errata/",

      editors: [
        { name: "Bryan-Elliott Tam", w3cid: "159160" },
        { name: "Ruben Taelman", w3cid: "84199" },
      ],


      //doJsonLd:     true,

      lint: { "no-unused-dfns": false }
    };
  </script>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <section id="abstract">
    <h2>Abstract</h2>
    <p>The open web and linked data are often seen as complementary,
      yet this doesn't imply that data publication should be disorganized.
      While the web as a whole lacks a clear structure, specific structures can be imposed on web segments through
      hypermedia descriptions and precise specifications.
      This document introduces the <em>Shape Index</em> specification,
      designed to facilitate data quality and query execution time in decentralized unindexed networks of linked data.
      The shape index leverages RDF data shapes to provide lightweight yet powerful structural and statistical
      information.</p>
  </section>

  <section id="aim">
    <h2>Aim, scope, and intended audience</h2>
    <p>
      The present document outlines how to annotate networks of datasets with a shape index and proposes methods
      by which the query engines can optimize traversal queries using this index.
      This document does not propose a mechanism for data validation, particularly continuous data validation during the
      insertion operations and update of the data model or structure of publication.
      The voice of the document is mostly from the perspective of developers who want to use the shape index for query
      optimization.
    </p>
  </section>

  <section id="conventions">
    <h2>Document Conventions</h2>
    <p>
      All assertions, diagrams, examples, and notes are non-normative, as are all sections explicitly marked
      non-normative. Everything else is normative.
    </p>

    <p>When this document uses the words <strong>MUST</strong>, <strong>MUST NOT</strong>, <strong>SHOULD</strong>,
      <strong>SHOULD NOT</strong>, <strong>MAY</strong> and
      <strong>RECOMMANDED</strong>, and the words appear all capitals, they must be interpreted as described in
      <a data-cite="rfc2119#">RFC 2119</a>.
    </p>

    <p>
      The following prefixes are used throughout the document.
    </p>
    <pre class="query nohighlight">
      PREFIX si: &lt;http://www.shapeindex.com#&gt;
      PREFIX ex: &lt;http://www.example.com#&gt;   
    </pre>
  </section>

  <section id="terminology">
    <h2>Terminology</h2>
    <dl>
      <dt>Subweb</dt>
      <dd>A subsection of the web, defined by a set of IRIs or IRI patterns.</dd>

      <dt>RDF Data Shape</dt>
      <dd>A schema definition for an RDF subgraph, independent of any specific shape language. Typically, this MAY be
        formalized in ShEx or SHACL.
        Used interchangeably with the shortening shape. (REFERENCE SHOULD BE ADDEDE TO SHEX AND SHACL)
      </dd>

      <dt>Complete Index</dt>
      <dd>An index that fully describes every resource within its associated subweb.</dd>

      <dt>Open shape</dt>
      <dd>A shape with a open world assumption, meaning that data respecting the shape can containing more non
        contradicting information than what is described.</dd>

      <dt>Close shape</dt>
      <dd>A shape with a close world assumption,
        meaning that the shape describes the whole set of information data must contain,
        hence a set of data containing more information does not respect the shape.</dd>
    </dl>
  </section>

  <section id="shape-index">
    <h2>Shape Index</h2>
    <p>
      A shape index is a scoped mapping between sets of RDF resources and RDF data shapes.
      In this context, a scope means that the index is characterized by a pair identifying a subweb `si:subweb` and the
      completeness of the index `si:complete`.
      A subweb is a set of IRI or IRI patterns manage by the data provider, the completeness of a
      shape index indicates if every resource in the subweb is associated with a shape.
      This characterization of the scope of the index is useful for two reasons.
      First, query optimizations related to the shape index are local, hence it is interesting for query engines
      to know which subwebs are affected by the optimization when performing traversal queries.
      Second, it is OPTIONAL to describe within a shape index every resource of a subweb, however, it is RECOMMENDED.
      Data providers might not want to describe every resource in its subweb to reduce potential computational time
      associated
      with keeping the mapping valid or to give themselves more flexibility in their data publication paradigm in a
      section of their subweb.
    </p>

    <p>
      The core feature of the shape index is its mappings.
      A shape index can have multiple entries identified by the term`si:hasEntry`.
      Each entry includes a target set identified by the term `si:target`.
      Target sets are bound by a shape identified by the term `si:bindByShape`.
      The target is a set of RDF resources where every triple within them MUST be validated by the shape linked to the
      target through a `si:bindByShape` annotation.
    </p>

    <pre class="query nohighlight">
      &lt;http://mySubweb.com/index1&gt; a si:ShapeIndex ;
        si:subweb &lt;http://mySubweb.com/&gt; ;
        si:subweb "http://mySubweb.com/0/data/.*/*" ;
        si:hasEntry [
          a si:Entry ;
          si:bindByShape ex:profile#ProfileShape ;
          si:target &lt;http://mySubweb.com/profile&gt;
        ], [
          a si:Entry ;
          si:bindByShape ex:movieReview#movieReviewShape ;
          si:target "http://mySubweb.com/0/data/movie_review/.*"
        ] , [
          a si:Entry ;
          si:bindByShape &lt;http://mySubweb.com/readingList#readingListShape&gt; ;
          si:target &lt;http://mySubweb.com/0/data/personal_reading_list&gt;
          si:target &lt;http://mySubweb.com/0/data/research/paper_list&gt;
          si:target "http://mySubweb.com/0/data/reading_list/*"
        ] ;
        si:isComplete true .  
    </pre>

    <p>
      Furthermore, every set of triples within the subweb respecting a shape with a close world assumption associated
      with a `si:bindByShape` MUST be inside a resource of the target annotated with the shape.
      It is RECOMMENDED to use shapes with close-world assumptions.
      If shapes with open-world assumptions are used then, triples respecting the shape SHOULD be inside a resource of
      the target.
    </p>

    <p>
      Given shapes contained with each other used as binding for targets (see the example below and notice that the
      shapes are open) then a set of triples respecting the most restrictive shape (`ex:Citizen` in the example) SHOULD
      be located inside the resources of this target.
      In a similar case but with closed shapes, the set of triples MUST be located at the target of the most restrictive
      shape.
      If a set of triples can be validated by an open and a closed shape, the set MUST be inside the target of the
      closed shape. A resource MUST only be bound to a maximum of one shape.
    </p>

    <pre class="query nohighlight">
      PREFIX ex: &lt;http://example.com/#&gt;
      PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
      PREFIX school: &lt;http://school.example/#&gt;
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

      ex:Human {
        foaf:name xsd:string ;
      }

      ex:Citizen {
        foaf:name xsd:string ;
        ex:socialSecurityNumber xsd:string ;
      }
    </pre>
  </section>

  <section id="negative-entries">
    <h2>Negative Entries</h2>
    <p>
      The shape index provides the ability to describe RDF data shapes that are not present within a subweb.
      This is indicated using the `si:doesNotContain` property with a specific shape associated.
      These shapes MUST adhere to a closed-world assumption, ensuring that no sets of triples within the entire subweb
      validate against this shape.
      It is RECOMMENDED to use these entries alongside shape constraints in the index, particularly to specify when
      nested shapes are absent from the subweb.
    </p>

    <pre class="query nohighlight">
      &lt;http://mySubweb.com/index2&gt; a si:ShapeIndex ;
        si:subweb "http://mySubweb.com/1/data/.*/*" ;
        si:hasEntry [
          a si:Entry ;
          si:bindByShape ex:profile#ProfileShape ;
          si:target &lt;http://mySubweb.com/profile&gt;
        ];

        si:doesNotContain ex:plant#PlantShapes.
        si:doesNotContain ex:car#CarShapes.

        si:isComplete true .
    </pre>
  </section>

  <section id="shape-index-discovery">
    <h2>How to Discover a Shape Index</h2>
    <p>
      The discovery of the shape index is left to the data provider.
      However, two approaches are RECOMMENDED.
    </p>

    <p>
      The data provider can use the predicate`si:shapeIndexLocation` with as an object the IRI of the shape index.
      This triple can be placed at convenient locations in the data provider subweb.
      Examples of such placements are at the root, at the location where other dataset information is provided, or in
      every file of the subweb.
    </p>

    <p>
      Another RECOMMENDED approach is to advertise the location of the shape index in the HTTP header.
      This SHOULD be in the form `Link: <iri-of-the-shape-index>; rel="http://www.shapeindex.com#shapeIndexLocation"`.
    </p>
  </section>

  <section id="query-optimization">
    <h2>Shape Index for Query Optimization</h2>

    <bold>
      This section is non-normative
    </bold>

    <p>
      One of the main objectives of the shape index is query optimization.
      This section provides an overview of the current approaches used to optimize queries with the shape index.
      As this section is non-normative and practices can evolve, it is subject to change. Readers are encouraged to
      contact the maintainers to propose new approaches or suggest extensions to the shape index based on techniques
      that build upon this approach.
    </p>

    <h3>Search Space Optimization</h3>
    <p>
      The shape index shares some similarities with the [Type Indexes](https://solid.github.io/type-indexes/index.html)
      (reference added at the end).
      Data discovery techniques like the one presented by [Taelman et
      al.](https://comunica.github.io/Article-ISWC2023-SolidQuery/) (reference added at the end) can be employed with
      small adaptations.
      [Taelman et al.](https://comunica.github.io/Article-ISWC2023-SolidQuery/)'s technique involves pruning sources
      associated with entries that do not share predicates with the user's query. Although this approach is an
      non-evaluated extension of their original method, it is expected to deliver performance that is equal to or better
      than the results presented in their paper.
    </p>

    <p>
      Another approach, however, built to use the shape index, has been proposed by [Tam et
      al.](https://github.com/constraintAutomaton/AWM-shape-index-short-paper). This approach involves translating
      shapes into SPARQL algebra and performing a query containment problem between the userâ€™s query and the translated
      shapes to determine which sources to dereference, taking into account the subweb and the completeness of the
      index. This method has been shown to significantly reduce query execution time compared to the approach by
      [Taelman et al.](https://comunica.github.io/Article-ISWC2023-SolidQuery/). However, it does not consider negative
      entries and has not been as extensively evaluated as [Taelman et
      al.](https://comunica.github.io/Article-ISWC2023-SolidQuery/)'s method.
    </p>
  </section>

  <section id="index"></section>

</body>

</html>